#ifndef COMMON_INTERFACES_H
#define COMMON_INTERFACES_H

#define DEFAULT_BUFF_SIZE 100

/******************************************************************************
 *****************         ARHITECTURE  DATA STORAGE         ******************
 *****************************************************************************/

// represents one architecture's implementation 
typedef struct{
    char name[DEFAULT_BUFF_SIZE];
    
    int columns;
    int rows;

    int config_time; // configuration time
    int config_power; // configuration power
    
    int exec_time; // execution time (AKA latency)
    int exec_power; // execution power (or energy???)
    
    char mode[DEFAULT_BUFF_SIZE];  // FIX
} Implementation;


// contains all of the architectures of an task
typedef struct{
    char name[DEFAULT_BUFF_SIZE]; // FIX - Make constants
    int id;
    
    int num_impl;           // the number of architectures for this task
    Implementation * impl;  // the properties of each architecture
} Task_Type;


typedef struct{
    char name[DEFAULT_BUFF_SIZE];
    char date[DEFAULT_BUFF_SIZE];
    
    int num_tasks;
    Task_Type * task;
} Architecture_Library;



/******************************************************************************
 * NAME : initArchLibrary
 * 
 * PURPOSE : Imports the architecture information from a file
 * ARGUMENTS : char * = name of the file containing the architecture data
 *             Architecture_library * = The strct that will hold all of the 
 *                      information from the aforementioned data file.
 * 
 * RETURNS : EXIT_FAILURE if the filename could not be found or opened or the
 *              file did not follow the specified format
 *           EXIT_SUCCESS otherwise
 * 
 * NOTE : please see the README file for more information about the format
 *              and contents of the architecture information file
 *****************************************************************************/
int initArchLibrary(char *, Architecture_Library *);

/******************************************************************************
 * NAME : freeArchLibrary
 * 
 * PURPOSE : Frees all dynamically allocated memory used to store the 
 *              architecture library
 * 
 * PRECONDITIONS : This function should only be called if initArchLibrary()
 *                  returned EXIT_SUCCESS
 *****************************************************************************/
void freeArchLibrary(Architecture_Library *);

/******************************************************************************
 * NAME : printArchLibrary
 * 
 * PURPOSE : print the library of architectures (The entire structure)
 * 
 * PRECONDITIONS : the architecture library MUST have been previously  
 *                      initialized by initArchLibrary()
 * 
 * NOTE : this function exists for testing and debugging purposes only.
 *****************************************************************************/
void printArchLibrary(Architecture_Library *);



/******************************************************************************
 *****************              DFG DATA STORAGE             ******************
 *****************************************************************************/

// FIX - Needs commenting
typedef struct{
    char name[DEFAULT_BUFF_SIZE];
    
    int task_type;
    char ** inputs;
    char output[DEFAULT_BUFF_SIZE]; // FIX - Make dynamic?
} Node;


// FIX - Needs commenting
typedef struct{
    char name[DEFAULT_BUFF_SIZE];
    char date[DEFAULT_BUFF_SIZE];
    
    char ** inputs;
    char ** outputs;
    char ** regs;
    int num_regs;
    
    int num_nodes;  // the number of nodes in the DFG
    Node * node;  // the properties of a node
} DFG;



/******************************************************************************
 * NAME : initDFG
 * 
 * PURPOSE : Imports the DFG information from a file
 * ARGUMENTS : char * = name of the file containing the dfg (that was
 *                      previously generated by Ahmed's dfgGenerator)
 *             DFG * = The strct that will hold all of the 
 *                      information from the aforementioned data file.
 * 
 * RETURNS : EXIT_FAILURE if the filename could not be found or opened or the
 *              file did not follow the specified format
 *           EXIT_SUCCESS otherwise
 * 
 * NOTE : please see the README file for more information about the format
 *              and contents of the DFG information file
 *****************************************************************************/
int initDFG(char *, DFG *);

/******************************************************************************
 * NAME : freeDFG
 * 
 * PURPOSE : Frees all dynamically allocated memory used to store the DFG
 * 
 * PRECONDITIONS : This function should only be called if initDFG()
 *                  returned EXIT_SUCCESS
 *****************************************************************************/
void freeDFG(DFG *);

/******************************************************************************
 * NAME : printDFG
 * 
 * PURPOSE : print the DFG (The entire structure)
 * 
 * PRECONDITIONS : the DFG structure MUST have been previously  
 *                      initialized by initDFG()
 * 
 * NOTE : this function exists for testing and debugging purposes only.
 *****************************************************************************/
void printDFG(DFG *);



/******************************************************************************
 *****************           HARDWARE DATA STORAGE           ******************
 *****************************************************************************/

// FIX - Needs commenting
typedef struct{
    int num_prrs;
    int num_gpps;
    int * prr_config_time;
    
    char name[DEFAULT_BUFF_SIZE];
} Processing_Elelements;


// FIX - Needs commenting
typedef struct{
    char name[DEFAULT_BUFF_SIZE];
    char date[DEFAULT_BUFF_SIZE];
    
    int num_setups;
    Processing_Elelements * setups;
} Hardware;



/******************************************************************************
 * NAME : initHardwareLibrary
 * 
 * PURPOSE : Imports the DFG information from a file
 * ARGUMENTS : char * = name of the file containing the Hardware information
 *             Hardware * = The strct that will hold all of the 
 *                      information from the aforementioned data file.
 * 
 * RETURNS : EXIT_FAILURE if the filename could not be found or opened or the
 *              file did not follow the specified format
 *           EXIT_SUCCESS otherwise
 * 
 * NOTE : please see the README file for more information about the format
 *              and contents of the hardware information file
 *****************************************************************************/
int initHardwareLibrary(char *, Hardware *);

/******************************************************************************
 * NAME : freeHardwareLibrary
 * 
 * PURPOSE : Frees all dynamically allocated memory used to store the hardware
 *              information / setups
 * 
 * PRECONDITIONS : This function should only be called if initDFG()
 *                  returned EXIT_SUCCESS
 *****************************************************************************/
void freeHardwareLibrary(Hardware *);

/******************************************************************************
 * NAME : printHardwareLibrary
 * 
 * PURPOSE : print the hardware setups (The entire structure)
 * 
 * PRECONDITIONS : the Hardware structure library MUST have been previously  
 *                      initialized by initHardwareLibrary()
 * 
 * NOTE : this function exists for testing and debugging purposes only.
 *****************************************************************************/
void printHardwareLibrary(Hardware *);



/******************************************************************************
 *****************           ENCAPSULATING STRUCT            ******************
 *****************************************************************************/

typedef struct {
    Architecture_Library archlib;
    DFG dfg;
    Processing_Elelements setup;
} Common_Interface;

#endif // COMMON_INTERFACES_H
